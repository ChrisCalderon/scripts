#!/usr/bin/python3
# -*- mode: python -*-
'''hex [OPTIONS] [PATH]
A utility for encoding input as hex.

Options:
  -r, --random-bytes   Outputs random hex encoded bytes
  -f, --file           Encodes the contents of a file as hex.
  -n, --no-newline     No trailing newline on output.
  -h, --help           Shows this help.

Notes:
    If used without any options, hex will simply encode it's input, either from
  stdin or the first argument, and then print it to the console. For example:

    some_util | hex
    hex lolol

  Examples for encoding a file:

    hex -f my_file
    hex -fmy_file
    hex --file my_file
    hex --file=my_file

  Getting hex-encoded random bytes:
    
    hex -r 8
    hex -r8
    hex --random-bytes 8
    hex --random-bytes=8

    To get output without a trailing newline, use the -n option, or it's long
  form --no-newline.

    hex -n lololol
    hex --no-newline lololol  

  Options combine in the usual way:
    
    hex -n -f my_file
    hex -nf my_file
    hex -n --random-bytes 10
'''
import select
import codecs
import getopt
import locale
import sys
import os

hex_encoder = codecs.getencoder('hex')

def hexify(stringy, encoding=locale.getlocale()[1]):
    '''Encodes a string or bytes type as a hex string.'''
    if isinstance(stringy, str):
        stringy = stringy.encode(encoding)
    if isinstance(stringy, (bytes, bytearray)):
        encoded = hex_encoder(stringy)[0].decode(encoding)
        return encoded
    raise ValueError('stringy must be of type str, bytes, or bytearray!')

def readable(*files):
    return select.select(files, [], [], 0.1)[0]    

def main():
    try:
        options, extra_args = getopt.getopt(sys.argv[1:],
                                            'nr:f:h',
                                            ['no-newline',
                                             'file=',
                                             'help',
                                             'random-bytes='])
    except getopt.GetoptError as err:
        print(err)
        print(__doc__)
        return 2

    filename = None
    random_bytes = None
    last_char = os.linesep
    for o, a in options:
        if o in ('-f', '--file') and filename==random_bytes==None:
            filename = a
        elif o in ('-r', '--random-bytes') and filename==random_bytes==None:
            try:
                random_bytes = int(a)
            except ValueError as err:
                print('Bad value for ', o)
                print(__doc__)
                return 2
            if random_bytes < 1:
                print('Value for -r must be >= 1!')
                print(__doc__)
                return 2
        elif o in ('-h', '--help'):
            print(__doc__)
            sys.exit()
        elif o in ('-n', '--no-newline'):
            last_char = ''
        else:
            print('Incorrect usage!')
            print(__doc__)
            return 2

    if filename==random_bytes==None and len(extra_args)==1:
        data = extra_args[0]
    elif len(extra_args):
        print('Too many args!')
        print(__doc__)
        return 2
    elif filename==random_bytes==None:
        if readable(sys.stdin):
            data = sys.stdin.read()
        else:
            print('Nothing to read from stdin!')
            print(__doc__)
            return 1
    elif filename is None and random_bytes:
        data = os.urandom(random_bytes)
    elif random_bytes is None and filename and os.path.isfile(filename):
        data = open(filename).read()
    else:
        print('Incorrect usage!')
        print(__doc__)
        return 2

    print(hexify(data), end=last_char)
    return 0

if __name__ == '__main__':
    sys.exit(main())
